# 浏览器安全相关

# 一、XSS攻击

XSS攻击（cross site scripting），跨站脚本。xss指的是利用浏览器执行恶意脚本（无论有无跨域），从而进行恶意操作的行为。

攻击目标一般多为：

- 窃取网站cookie
- 监听用户行为，比如监听用户输入账号密码
- 修改DOM，比如伪造登陆表单，发送账号密码
- 在页面中生成广告等

xss攻击一般分`存储型、反射型、文档型`

## 存储型

存储型xss攻击是将攻击的脚本存储至数据库中，又将该脚本发送至客户端，达到攻击目的。

以前微博的评论貌似就中招过（小声哔哔），攻击者通过在评论中输入脚本，并上传至服务器的数据库中，当另外的客户端加载了这条评论时就会执行这段脚本，从而达到攻击的目的。现在前后端一般都会做转义工作了（将特殊符号，脚本里面的符号进行转义），一般来说这一种攻击不太容易中招了。

## 反射型

反射型攻击是通过一个url向服务器发送请求。服务器得到这个请求后，响应请求，将这段信息直接当做HTML返回给浏览器，但是这段信息是一个脚本，所以浏览器直接执行了。
比如
```http
http://baidu.com?kw=<script>document.write('你被我劫持了')</script>
```
之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。

## 文档型

文档型的xss攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！

这样的劫持方式包括`WIFI路由器劫持`或者`本地恶意软件`等。


## 如何防范

明白了这些攻击的原理，其实还是很好防范的。这些攻击方式都是让脚本在浏览器中执行，那我们要做的就是不让恶意脚本在浏览器中执行即可。

1. 转义输入

用户的输入是不应该被信任的，你无法控制用户的输入。所以，不管用户输入了什么，前后端都应该进行转义

2. CSP

CSP，即浏览器中的内容安全策略，它的核心思想就是`服务器决定浏览器`加载哪些资源，具体来说可以完成以下功能:

    1. 限制其他域下的资源加载。
    2. 禁止向其它域提交数据。
    3. 提供上报机制，能帮助我们及时发现 XSS 攻击。

3. HyypOnly

很多XSS攻击的主要对象都是cookie，因为用户的登陆信息一般存储在cookie中，设置了HttpOnly之后，脚本是无法操作cookie的，只有http请求可以操作。

# 二、CSRF攻击

CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。

假如说，你现在登录了微博，然后浏览到一张性感美女的照片，你没有忍住，点了进去。那么恭喜你，你中招了。

为什么中招了？因为这时候你已经登录了，该域名下存储了你的登陆cookie，黑客就可以通过cookie，伪造自己是你

## 图片自动发送GET请求

利用图片的src属性，自动发送get请求，而这个请求会携带上你的cookie，注意，这是一个http请求！
```html
<img src='http://weibo.com?userinfo=info&usersex=sex'>
```
## 表单自动发送请求

黑客可以自动填写，设置自动提交表单，从而在这个提交表单的请求中携带你的登陆信息，让服务器认为是你自己在操作。

## 诱导链接点击

```html
<a href='http://weibo.com?userinfo=info&usersex=sex'>点击查看36D小姐姐</a>
```

和XSS攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态来模拟用户进行操作。

## 如何防范

1. Samesite

CSRF攻击中重要的一环就是自动发送目标站点下的 Cookie,然后就是这一份 Cookie 模拟了用户的身份。因此我们处理好cookie是可以避免csrf攻击的。

恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是SameSite。

SameSite可以设置为三个值，Strict、Lax和None。

    1. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求weibo.com网站只能在weibo.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
    2. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
    3. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。

2. 验证来源

这就需要要用到请求头中的两个字段: `Origin和Referer`。

其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。

当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。

3. CSRF Token

浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。

然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就会被服务器给拒绝。


# 三、HTTPS为什么让请求更安全

https它其实并不是一个新的协议，而是http协议的增强版。

http在请求的时候是明文传输的，因此，他可能在任何阶段被攻击。经过tcp层、wifi路由、运营商、目标服务器，这些环节都有可能被攻击者拿到数据，进行攻击。这就是`中间人攻击`

这个时候就有了https，他在建立tcp链接的时候，还会建立一个tls链接，使得http和tcp/ip通信的时候并不会直接通信，而是会经过中间层加密 解密。

## 对称加密&非对称加密

