# js单线程

js的事件分两种，宏任务(macro-task)和微任务(micro-task)，大部分的任务都是在主线程上执行，常见的任务有:

    1. 渲染事件
    2. 用户交互事件
    3. js脚本执行
    4. 网络请求、文件读写完成等事件

在js引擎执行这些事件时，需要依据一定的顺序去执行，V8引擎 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。

事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，`同步的进入主线程`，`异步的进入Event Table`并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。

### 宏任务

包括整体代码script，setTimeout，setInterval

宏任务在js主线程中运行，先进入先执行。而延迟任务setTimeout和setInterval执行之后会返回一个微任务，进入微任务队列，等宏任务队列执行完了之后，再去微任务队列执行微任务

### 微任务

常见的微任务有MutationObserver、Promise.then(或reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程

V8引擎是将微任务放到当前宏任务的末尾。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务

### eventloop

当一个js执行时会按照什么顺序执行呢？

    1. 整个script作为第一个宏任务被执行
    2. script执行中，宏任务进入宏任务队列，微任务进入微任务队列
    3. 执行宏任务，宏任务执行完成之后，检查微任务队列
    4. 如果有微任务，执行微任务，直到微任务执行完毕
    5. 进行浏览器UI多线程渲染
    6. 检查web worker任务，有则执行
    7. 循环第2步，直到完成所有任务

- 下面js输出什么
```js
console.log(111)

setTimeout(() => {
    console.log(222)
}, 0)

Promise.resolve().then(() => console.log(333))
console.log(444)

// 111 444 333 222
```

为什么？

    1. console.log setTimeout都属于宏任务，console.log是同步任务，进入主线程执行
    2. setTimeout进入宏任务队列，promise.then属于微任务，进入微任务队列
    3. 本次宏任务执行完毕，检查微任务队列有一个promise.then，拿出来执行
    4. 下一次宏任务，检查到setTimeout，拿出来执行
