# node事件循环

![image](https://user-gold-cdn.xitu.io/2020/7/24/1737fe6072145007?w=690&h=378&f=jpeg&s=28669)

node中的事件循环和浏览器中还是有比较大区别的

浏览器中只有两个事件队列，一个宏队列，一个微队列。而node中，事件循环的每一个部分都有一个队列。

只有当这个阶段队列里面的所有任务都执行完了之后，才会进下一个阶段，继续清空任务队列


## timers 队列

存放计时器的回调函数

## poll 轮询队列

这里存放 除了times checks 队列之外的几乎所有回调函数

比如：文件读取回调  监听请求的回调

## checks 队列

`setImmediate`的回调函数会直接进入checks队列

## 整个流程梳理

node首先执行全局的同步代码，遇到 timers 就放入计时线程进行计时，遇到 setImmediate 直接放入checks队列，其余的异步操作，一般放入poll队列

1. 一个事件循环进入到timers， 去计时线程将所有的timer拿出来计算一下，看看有没有到时间

   - 如果到时间了，就将回调拿出来执行，直到所有到时间的回调全部执行完毕，进入下一个队列
   - 如果时间没有到，就直接进入下一个队列

注意，这里，其实timers严格意义上不算是一个队列，它是从计时线程拿出timer计算看看有没有到时间，由于这个计算，这也是为什么timer计时不准的原因之一

2. 进入到poll队列
   
    - 如果没有这里没有任务需要执行，看看其他队列有没有需要执行的任务
        - 没有的话就在这个队列等待，直到其他队列有任务需要执行了，进入下一个队列
        - 如果其他队列一直没有任务需要执行，在poll队列等待足够长的时间，进入下一个队列
    - 如果这里有任务需要执行，清空这个任务队列。

3. 进入到check队列
    
    清空队列，在进入下一个阶段

```js
setTimeout(() => {
    console.log(1)
}, 0)

fs.readFile('./index.js', (err, data) => {
    console.log(2)
})

setImmediate(() => {
    console.log(3)
})

console.log(4)

// 4 1 3 2
```

首先执行全局的同步代码，将timer放入计时线程， 将读取文件放入poll， 将setImmediate放入checks， 输出 4

进入时间循环，正好timeout计时完毕，拿出来执行，输出 1 ，没有其他到时间的计时器，进入poll队列

读取文件，需要一定时间，本来应该就是poll等待，结果发现checks有任务，进入checks

进入checks 输出3

进入下一次循环。。。 进过timer，到达poll，等待，文件读取完了，输出2，等待，发现没有其他任务了

结束。